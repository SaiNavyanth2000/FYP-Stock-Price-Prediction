{"ast":null,"code":"import { getScrollbarWidth } from '../scroll.js';\nimport { client } from '../../plugins/Platform.js';\nlet vpLeft, vpTop;\nexport function validatePosition(pos) {\n  const parts = pos.split(' ');\n\n  if (parts.length !== 2) {\n    return false;\n  }\n\n  if (['top', 'center', 'bottom'].includes(parts[0]) !== true) {\n    console.error('Anchor/Self position must start with one of top/center/bottom');\n    return false;\n  }\n\n  if (['left', 'middle', 'right', 'start', 'end'].includes(parts[1]) !== true) {\n    console.error('Anchor/Self position must end with one of left/middle/right/start/end');\n    return false;\n  }\n\n  return true;\n}\nexport function validateOffset(val) {\n  if (!val) {\n    return true;\n  }\n\n  if (val.length !== 2) {\n    return false;\n  }\n\n  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {\n    return false;\n  }\n\n  return true;\n}\nconst horizontalPos = {\n  'start#ltr': 'left',\n  'start#rtl': 'right',\n  'end#ltr': 'right',\n  'end#rtl': 'left'\n};\n['left', 'middle', 'right'].forEach(pos => {\n  horizontalPos[`${pos}#ltr`] = pos;\n  horizontalPos[`${pos}#rtl`] = pos;\n});\nexport function parsePosition(pos, rtl) {\n  const parts = pos.split(' ');\n  return {\n    vertical: parts[0],\n    horizontal: horizontalPos[`${parts[1]}#${rtl === true ? 'rtl' : 'ltr'}`]\n  };\n}\nexport function validateCover(val) {\n  if (val === true || val === false) {\n    return true;\n  }\n\n  return validatePosition(val);\n}\nexport function getAnchorProps(el, offset) {\n  let {\n    top,\n    left,\n    right,\n    bottom,\n    width,\n    height\n  } = el.getBoundingClientRect();\n\n  if (offset !== void 0) {\n    top -= offset[1];\n    left -= offset[0];\n    bottom += offset[1];\n    right += offset[0];\n    width += offset[0];\n    height += offset[1];\n  }\n\n  return {\n    top,\n    left,\n    right,\n    bottom,\n    width,\n    height,\n    middle: left + (right - left) / 2,\n    center: top + (bottom - top) / 2\n  };\n}\nexport function getTargetProps(el) {\n  return {\n    top: 0,\n    center: el.offsetHeight / 2,\n    bottom: el.offsetHeight,\n    left: 0,\n    middle: el.offsetWidth / 2,\n    right: el.offsetWidth\n  };\n} // cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }\n\nexport function setPosition(cfg) {\n  if (client.is.ios === true && window.visualViewport !== void 0) {\n    // uses the q-position-engine CSS class\n    const el = document.body.style;\n    const {\n      offsetLeft: left,\n      offsetTop: top\n    } = window.visualViewport;\n\n    if (left !== vpLeft) {\n      el.setProperty('--q-pe-left', left + 'px');\n      vpLeft = left;\n    }\n\n    if (top !== vpTop) {\n      el.setProperty('--q-pe-top', top + 'px');\n      vpTop = top;\n    }\n  }\n\n  let anchorProps; // scroll position might change\n  // if max-height/-width changes, so we\n  // need to restore it after we calculate\n  // the new positioning\n\n  const {\n    scrollLeft,\n    scrollTop\n  } = cfg.el;\n\n  if (cfg.absoluteOffset === void 0) {\n    anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset);\n  } else {\n    const {\n      top: anchorTop,\n      left: anchorLeft\n    } = cfg.anchorEl.getBoundingClientRect(),\n          top = anchorTop + cfg.absoluteOffset.top,\n          left = anchorLeft + cfg.absoluteOffset.left;\n    anchorProps = {\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      center: top,\n      middle: left,\n      bottom: top + 1\n    };\n  }\n\n  let elStyle = {\n    maxHeight: cfg.maxHeight,\n    maxWidth: cfg.maxWidth,\n    visibility: 'visible'\n  };\n\n  if (cfg.fit === true || cfg.cover === true) {\n    elStyle.minWidth = anchorProps.width + 'px';\n\n    if (cfg.cover === true) {\n      elStyle.minHeight = anchorProps.height + 'px';\n    }\n  }\n\n  Object.assign(cfg.el.style, elStyle);\n  const targetProps = getTargetProps(cfg.el),\n        props = {\n    top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],\n    left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]\n  };\n  applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);\n  elStyle = {\n    top: props.top + 'px',\n    left: props.left + 'px'\n  };\n\n  if (props.maxHeight !== void 0) {\n    elStyle.maxHeight = props.maxHeight + 'px';\n\n    if (anchorProps.height > props.maxHeight) {\n      elStyle.minHeight = elStyle.maxHeight;\n    }\n  }\n\n  if (props.maxWidth !== void 0) {\n    elStyle.maxWidth = props.maxWidth + 'px';\n\n    if (anchorProps.width > props.maxWidth) {\n      elStyle.minWidth = elStyle.maxWidth;\n    }\n  }\n\n  Object.assign(cfg.el.style, elStyle); // restore scroll position\n\n  if (cfg.el.scrollTop !== scrollTop) {\n    cfg.el.scrollTop = scrollTop;\n  }\n\n  if (cfg.el.scrollLeft !== scrollLeft) {\n    cfg.el.scrollLeft = scrollLeft;\n  }\n}\n\nfunction applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  const currentHeight = targetProps.bottom,\n        currentWidth = targetProps.right,\n        margin = getScrollbarWidth(),\n        innerHeight = window.innerHeight - margin,\n        innerWidth = document.body.clientWidth;\n\n  if (props.top < 0 || props.top + currentHeight > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      props.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;\n      props.maxHeight = Math.min(currentHeight, innerHeight);\n    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {\n      const anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top);\n      props.maxHeight = Math.min(currentHeight, anchorY);\n      props.top = Math.max(0, anchorY - currentHeight);\n    } else {\n      props.top = Math.max(0, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom);\n      props.maxHeight = Math.min(currentHeight, innerHeight - props.top);\n    }\n  }\n\n  if (props.left < 0 || props.left + currentWidth > innerWidth) {\n    props.maxWidth = Math.min(currentWidth, innerWidth);\n\n    if (selfOrigin.horizontal === 'middle') {\n      props.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;\n    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {\n      const anchorX = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left);\n      props.maxWidth = Math.min(currentWidth, anchorX);\n      props.left = Math.max(0, anchorX - props.maxWidth);\n    } else {\n      props.left = Math.max(0, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right);\n      props.maxWidth = Math.min(currentWidth, innerWidth - props.left);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/saina/OneDrive - City University of Hong Kong/Desktop/cityu/Cityu Year 4/FYP/code/frontend_sample2/node_modules/quasar/src/utils/private/position-engine.js"],"names":["getScrollbarWidth","client","vpLeft","vpTop","validatePosition","pos","parts","split","length","includes","console","error","validateOffset","val","horizontalPos","forEach","parsePosition","rtl","vertical","horizontal","validateCover","getAnchorProps","el","offset","top","left","right","bottom","width","height","getBoundingClientRect","middle","center","getTargetProps","offsetHeight","offsetWidth","setPosition","cfg","is","ios","window","visualViewport","document","body","style","offsetLeft","offsetTop","setProperty","anchorProps","scrollLeft","scrollTop","absoluteOffset","anchorEl","cover","anchorTop","anchorLeft","elStyle","maxHeight","maxWidth","visibility","fit","minWidth","minHeight","Object","assign","targetProps","props","anchorOrigin","selfOrigin","applyBoundaries","currentHeight","currentWidth","margin","innerHeight","innerWidth","clientWidth","Math","max","min","anchorY","anchorX"],"mappings":"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","sourcesContent":["import { getScrollbarWidth } from '../scroll.js'\nimport { client } from '../../plugins/Platform.js'\n\nlet vpLeft, vpTop\n\nexport function validatePosition (pos) {\n  const parts = pos.split(' ')\n  if (parts.length !== 2) {\n    return false\n  }\n  if ([ 'top', 'center', 'bottom' ].includes(parts[ 0 ]) !== true) {\n    console.error('Anchor/Self position must start with one of top/center/bottom')\n    return false\n  }\n  if ([ 'left', 'middle', 'right', 'start', 'end' ].includes(parts[ 1 ]) !== true) {\n    console.error('Anchor/Self position must end with one of left/middle/right/start/end')\n    return false\n  }\n  return true\n}\n\nexport function validateOffset (val) {\n  if (!val) { return true }\n  if (val.length !== 2) { return false }\n  if (typeof val[ 0 ] !== 'number' || typeof val[ 1 ] !== 'number') {\n    return false\n  }\n  return true\n}\n\nconst horizontalPos = {\n  'start#ltr': 'left',\n  'start#rtl': 'right',\n  'end#ltr': 'right',\n  'end#rtl': 'left'\n}\n\n;[ 'left', 'middle', 'right' ].forEach(pos => {\n  horizontalPos[ `${ pos }#ltr` ] = pos\n  horizontalPos[ `${ pos }#rtl` ] = pos\n})\n\nexport function parsePosition (pos, rtl) {\n  const parts = pos.split(' ')\n  return {\n    vertical: parts[ 0 ],\n    horizontal: horizontalPos[ `${ parts[ 1 ] }#${ rtl === true ? 'rtl' : 'ltr' }` ]\n  }\n}\n\nexport function validateCover (val) {\n  if (val === true || val === false) { return true }\n  return validatePosition(val)\n}\n\nexport function getAnchorProps (el, offset) {\n  let { top, left, right, bottom, width, height } = el.getBoundingClientRect()\n\n  if (offset !== void 0) {\n    top -= offset[ 1 ]\n    left -= offset[ 0 ]\n    bottom += offset[ 1 ]\n    right += offset[ 0 ]\n\n    width += offset[ 0 ]\n    height += offset[ 1 ]\n  }\n\n  return {\n    top,\n    left,\n    right,\n    bottom,\n    width,\n    height,\n    middle: left + (right - left) / 2,\n    center: top + (bottom - top) / 2\n  }\n}\n\nexport function getTargetProps (el) {\n  return {\n    top: 0,\n    center: el.offsetHeight / 2,\n    bottom: el.offsetHeight,\n    left: 0,\n    middle: el.offsetWidth / 2,\n    right: el.offsetWidth\n  }\n}\n\n// cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }\nexport function setPosition (cfg) {\n  if (client.is.ios === true && window.visualViewport !== void 0) {\n    // uses the q-position-engine CSS class\n\n    const el = document.body.style\n    const { offsetLeft: left, offsetTop: top } = window.visualViewport\n\n    if (left !== vpLeft) {\n      el.setProperty('--q-pe-left', left + 'px')\n      vpLeft = left\n    }\n    if (top !== vpTop) {\n      el.setProperty('--q-pe-top', top + 'px')\n      vpTop = top\n    }\n  }\n\n  let anchorProps\n\n  // scroll position might change\n  // if max-height/-width changes, so we\n  // need to restore it after we calculate\n  // the new positioning\n  const { scrollLeft, scrollTop } = cfg.el\n\n  if (cfg.absoluteOffset === void 0) {\n    anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [ 0, 0 ] : cfg.offset)\n  }\n  else {\n    const\n      { top: anchorTop, left: anchorLeft } = cfg.anchorEl.getBoundingClientRect(),\n      top = anchorTop + cfg.absoluteOffset.top,\n      left = anchorLeft + cfg.absoluteOffset.left\n\n    anchorProps = { top, left, width: 1, height: 1, right: left + 1, center: top, middle: left, bottom: top + 1 }\n  }\n\n  let elStyle = {\n    maxHeight: cfg.maxHeight,\n    maxWidth: cfg.maxWidth,\n    visibility: 'visible'\n  }\n\n  if (cfg.fit === true || cfg.cover === true) {\n    elStyle.minWidth = anchorProps.width + 'px'\n    if (cfg.cover === true) {\n      elStyle.minHeight = anchorProps.height + 'px'\n    }\n  }\n\n  Object.assign(cfg.el.style, elStyle)\n\n  const\n    targetProps = getTargetProps(cfg.el),\n    props = {\n      top: anchorProps[ cfg.anchorOrigin.vertical ] - targetProps[ cfg.selfOrigin.vertical ],\n      left: anchorProps[ cfg.anchorOrigin.horizontal ] - targetProps[ cfg.selfOrigin.horizontal ]\n    }\n\n  applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin)\n\n  elStyle = {\n    top: props.top + 'px',\n    left: props.left + 'px'\n  }\n\n  if (props.maxHeight !== void 0) {\n    elStyle.maxHeight = props.maxHeight + 'px'\n\n    if (anchorProps.height > props.maxHeight) {\n      elStyle.minHeight = elStyle.maxHeight\n    }\n  }\n  if (props.maxWidth !== void 0) {\n    elStyle.maxWidth = props.maxWidth + 'px'\n\n    if (anchorProps.width > props.maxWidth) {\n      elStyle.minWidth = elStyle.maxWidth\n    }\n  }\n\n  Object.assign(cfg.el.style, elStyle)\n\n  // restore scroll position\n  if (cfg.el.scrollTop !== scrollTop) {\n    cfg.el.scrollTop = scrollTop\n  }\n  if (cfg.el.scrollLeft !== scrollLeft) {\n    cfg.el.scrollLeft = scrollLeft\n  }\n}\n\nfunction applyBoundaries (props, anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  const\n    currentHeight = targetProps.bottom,\n    currentWidth = targetProps.right,\n    margin = getScrollbarWidth(),\n    innerHeight = window.innerHeight - margin,\n    innerWidth = document.body.clientWidth\n\n  if (props.top < 0 || props.top + currentHeight > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      props.top = anchorProps[ anchorOrigin.vertical ] > innerHeight / 2\n        ? Math.max(0, innerHeight - currentHeight)\n        : 0\n      props.maxHeight = Math.min(currentHeight, innerHeight)\n    }\n    else if (anchorProps[ anchorOrigin.vertical ] > innerHeight / 2) {\n      const anchorY = Math.min(\n        innerHeight,\n        anchorOrigin.vertical === 'center'\n          ? anchorProps.center\n          : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top)\n      )\n      props.maxHeight = Math.min(currentHeight, anchorY)\n      props.top = Math.max(0, anchorY - currentHeight)\n    }\n    else {\n      props.top = Math.max(0, anchorOrigin.vertical === 'center'\n        ? anchorProps.center\n        : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom)\n      )\n      props.maxHeight = Math.min(currentHeight, innerHeight - props.top)\n    }\n  }\n\n  if (props.left < 0 || props.left + currentWidth > innerWidth) {\n    props.maxWidth = Math.min(currentWidth, innerWidth)\n    if (selfOrigin.horizontal === 'middle') {\n      props.left = anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2\n        ? Math.max(0, innerWidth - currentWidth)\n        : 0\n    }\n    else if (anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2) {\n      const anchorX = Math.min(\n        innerWidth,\n        anchorOrigin.horizontal === 'middle'\n          ? anchorProps.middle\n          : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left)\n      )\n      props.maxWidth = Math.min(currentWidth, anchorX)\n      props.left = Math.max(0, anchorX - props.maxWidth)\n    }\n    else {\n      props.left = Math.max(0, anchorOrigin.horizontal === 'middle'\n        ? anchorProps.middle\n        : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right)\n      )\n      props.maxWidth = Math.min(currentWidth, innerWidth - props.left)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}