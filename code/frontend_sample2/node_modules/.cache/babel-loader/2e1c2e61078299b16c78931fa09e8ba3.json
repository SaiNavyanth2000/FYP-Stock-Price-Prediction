{"ast":null,"code":"import { h, ref, computed, watch, onActivated, onDeactivated, onBeforeMount, onBeforeUnmount, nextTick, getCurrentInstance } from 'vue';\nimport debounce from '../../utils/debounce.js';\nimport { noop } from '../../utils/event.js';\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js';\nconst aggBucketSize = 1000;\nconst scrollToEdges = ['start', 'center', 'end', 'start-force', 'center-force', 'end-force'];\nlet id = 1;\nconst filterProto = Array.prototype.filter;\nconst setOverflowAnchor = __QUASAR_SSR__ || window.getComputedStyle(document.body).overflowAnchor === void 0 ? noop : function (id, index) {\n  const ssId = id + '_ss';\n  let styleSheet = document.getElementById(ssId);\n\n  if (styleSheet === null) {\n    styleSheet = document.createElement('style');\n    styleSheet.type = 'text/css';\n    styleSheet.id = ssId;\n    document.head.appendChild(styleSheet);\n  }\n\n  if (styleSheet.qChildIndex !== index) {\n    styleSheet.qChildIndex = index;\n    styleSheet.innerHTML = `#${id} > *:nth-child(${index}) { overflow-anchor: auto }`;\n  }\n};\n\nfunction sumFn(acc, h) {\n  return acc + h;\n}\n\nfunction getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {\n  const parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,\n        propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',\n        details = {\n    scrollStart: 0,\n    scrollViewSize: -stickyStart - stickyEnd,\n    scrollMaxSize: 0,\n    offsetStart: -stickyStart,\n    offsetEnd: -stickyEnd\n  };\n\n  if (horizontal === true) {\n    if (parent === window) {\n      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;\n      details.scrollViewSize += document.documentElement.clientWidth;\n    } else {\n      details.scrollStart = parentCalc.scrollLeft;\n      details.scrollViewSize += parentCalc.clientWidth;\n    }\n\n    details.scrollMaxSize = parentCalc.scrollWidth;\n\n    if (rtl === true) {\n      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;\n    }\n  } else {\n    if (parent === window) {\n      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;\n      details.scrollViewSize += document.documentElement.clientHeight;\n    } else {\n      details.scrollStart = parentCalc.scrollTop;\n      details.scrollViewSize += parentCalc.clientHeight;\n    }\n\n    details.scrollMaxSize = parentCalc.scrollHeight;\n  }\n\n  if (beforeRef !== null) {\n    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetStart += el[propElSize];\n      }\n    }\n  }\n\n  if (afterRef !== null) {\n    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetEnd += el[propElSize];\n      }\n    }\n  }\n\n  if (child !== parent) {\n    const parentRect = parentCalc.getBoundingClientRect(),\n          childRect = child.getBoundingClientRect();\n\n    if (horizontal === true) {\n      details.offsetStart += childRect.left - parentRect.left;\n      details.offsetEnd -= childRect.width;\n    } else {\n      details.offsetStart += childRect.top - parentRect.top;\n      details.offsetEnd -= childRect.height;\n    }\n\n    if (parent !== window) {\n      details.offsetStart += details.scrollStart;\n    }\n\n    details.offsetEnd += details.scrollMaxSize - details.offsetStart;\n  }\n\n  return details;\n}\n\nfunction setScroll(parent, scroll, horizontal, rtl) {\n  if (scroll === 'end') {\n    scroll = (parent === window ? document.body : parent)[horizontal === true ? 'scrollWidth' : 'scrollHeight'];\n  }\n\n  if (parent === window) {\n    if (horizontal === true) {\n      if (rtl === true) {\n        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;\n      }\n\n      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);\n    } else {\n      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);\n    }\n  } else if (horizontal === true) {\n    if (rtl === true) {\n      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;\n    }\n\n    parent.scrollLeft = scroll;\n  } else {\n    parent.scrollTop = scroll;\n  }\n}\n\nfunction sumSize(sizeAgg, size, from, to) {\n  if (from >= to) {\n    return 0;\n  }\n\n  const lastTo = size.length,\n        fromAgg = Math.floor(from / aggBucketSize),\n        toAgg = Math.floor((to - 1) / aggBucketSize) + 1;\n  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);\n\n  if (from % aggBucketSize !== 0) {\n    total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);\n  }\n\n  if (to % aggBucketSize !== 0 && to !== lastTo) {\n    total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);\n  }\n\n  return total;\n}\n\nconst commonVirtScrollProps = {\n  virtualScrollSliceSize: {\n    type: [Number, String],\n    default: null\n  },\n  virtualScrollSliceRatioBefore: {\n    type: [Number, String],\n    default: 1\n  },\n  virtualScrollSliceRatioAfter: {\n    type: [Number, String],\n    default: 1\n  },\n  virtualScrollItemSize: {\n    type: [Number, String],\n    default: 24\n  },\n  virtualScrollStickySizeStart: {\n    type: [Number, String],\n    default: 0\n  },\n  virtualScrollStickySizeEnd: {\n    type: [Number, String],\n    default: 0\n  },\n  tableColspan: [Number, String]\n};\nexport const commonVirtPropsList = Object.keys(commonVirtScrollProps);\nexport const useVirtualScrollProps = {\n  virtualScrollHorizontal: Boolean,\n  onVirtualScroll: Function,\n  ...commonVirtScrollProps\n};\nexport function useVirtualScroll({\n  virtualScrollLength,\n  getVirtualScrollTarget,\n  getVirtualScrollEl,\n  virtualScrollItemSizeComputed // optional\n\n}) {\n  const vm = getCurrentInstance();\n  const {\n    props,\n    emit,\n    proxy\n  } = vm;\n  const {\n    $q\n  } = proxy;\n  let prevScrollStart,\n      prevToIndex,\n      localScrollViewSize,\n      virtualScrollSizesAgg = [],\n      virtualScrollSizes;\n  const vsId = 'qvs_' + id++;\n  const virtualScrollPaddingBefore = ref(0);\n  const virtualScrollPaddingAfter = ref(0);\n  const virtualScrollSliceSizeComputed = ref({});\n  const beforeRef = ref(null);\n  const afterRef = ref(null);\n  const contentRef = ref(null);\n  const virtualScrollSliceRange = ref({\n    from: 0,\n    to: 0\n  });\n  const colspanAttr = computed(() => props.tableColspan !== void 0 ? props.tableColspan : 100);\n\n  if (virtualScrollItemSizeComputed === void 0) {\n    virtualScrollItemSizeComputed = computed(() => props.virtualScrollItemSize);\n  }\n\n  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ';' + props.virtualScrollHorizontal);\n  const needsSliceRecalc = computed(() => needsReset.value + ';' + props.virtualScrollSliceRatioBefore + ';' + props.virtualScrollSliceRatioAfter);\n  watch(needsSliceRecalc, () => {\n    setVirtualScrollSize();\n  });\n  watch(needsReset, reset);\n\n  function reset() {\n    localResetVirtualScroll(prevToIndex, true);\n  }\n\n  function refresh(toIndex) {\n    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex);\n  }\n\n  function scrollTo(toIndex, edge) {\n    const scrollEl = getVirtualScrollTarget();\n\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return;\n    }\n\n    const scrollDetails = getScrollDetails(scrollEl, getVirtualScrollEl(), beforeRef.value, afterRef.value, props.virtualScrollHorizontal, $q.lang.rtl, props.virtualScrollStickySizeStart, props.virtualScrollStickySizeEnd);\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);\n    setVirtualScrollSliceRange(scrollEl, scrollDetails, Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)), 0, scrollToEdges.indexOf(edge) > -1 ? edge : prevToIndex > -1 && toIndex > prevToIndex ? 'end' : 'start');\n  }\n\n  function localOnVirtualScrollEvt() {\n    const scrollEl = getVirtualScrollTarget();\n\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return;\n    }\n\n    const scrollDetails = getScrollDetails(scrollEl, getVirtualScrollEl(), beforeRef.value, afterRef.value, props.virtualScrollHorizontal, $q.lang.rtl, props.virtualScrollStickySizeStart, props.virtualScrollStickySizeEnd),\n          listLastIndex = virtualScrollLength.value - 1,\n          listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value;\n\n    if (prevScrollStart === scrollDetails.scrollStart) {\n      return;\n    }\n\n    if (scrollDetails.scrollMaxSize <= 0) {\n      setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);\n      return;\n    }\n\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);\n    updateVirtualScrollSizes(virtualScrollSliceRange.value.from);\n    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));\n\n    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {\n      setVirtualScrollSliceRange(scrollEl, scrollDetails, listLastIndex, scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0));\n      return;\n    }\n\n    let toIndex = 0,\n        listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,\n        offset = listOffset;\n\n    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {\n      listOffset -= virtualScrollPaddingBefore.value;\n      toIndex = virtualScrollSliceRange.value.from;\n      offset = listOffset;\n    } else {\n      for (let j = 0; listOffset >= virtualScrollSizesAgg[j] && toIndex < listLastIndex; j++) {\n        listOffset -= virtualScrollSizesAgg[j];\n        toIndex += aggBucketSize;\n      }\n    }\n\n    while (listOffset > 0 && toIndex < listLastIndex) {\n      listOffset -= virtualScrollSizes[toIndex];\n\n      if (listOffset > -scrollDetails.scrollViewSize) {\n        toIndex++;\n        offset = listOffset;\n      } else {\n        offset = virtualScrollSizes[toIndex] + listOffset;\n      }\n    }\n\n    setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset);\n  }\n\n  function setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset, align) {\n    const alignForce = typeof align === 'string' && align.indexOf('-force') > -1;\n    const alignEnd = alignForce === true ? align.replace('-force', '') : align;\n    const alignRange = alignEnd !== void 0 ? alignEnd : 'start';\n    let from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[alignRange]),\n        to = from + virtualScrollSliceSizeComputed.value.total;\n\n    if (to > virtualScrollLength.value) {\n      to = virtualScrollLength.value;\n      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total);\n    }\n\n    prevScrollStart = scrollDetails.scrollStart;\n    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to;\n\n    if (rangeChanged === false && alignEnd === void 0) {\n      emitScroll(toIndex);\n      return;\n    }\n\n    const {\n      activeElement\n    } = document;\n    const contentEl = contentRef.value;\n\n    if (rangeChanged === true && contentEl !== null && contentEl !== activeElement && contentEl.contains(activeElement) === true) {\n      contentEl.addEventListener('focusout', onBlurRefocusFn);\n      setTimeout(() => {\n        contentEl !== void 0 && contentEl.removeEventListener('focusout', onBlurRefocusFn);\n      });\n    }\n\n    setOverflowAnchor(vsId, toIndex - from + 1);\n    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;\n\n    if (rangeChanged === true) {\n      // vue key matching algorithm works only if\n      // the array of VNodes changes on only one of the ends\n      // so we first change one end and then the other\n      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to ? virtualScrollSliceRange.value.to : to;\n      virtualScrollSliceRange.value = {\n        from,\n        to: tempTo\n      };\n      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from);\n      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);\n      requestAnimationFrame(() => {\n        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {\n          virtualScrollSliceRange.value = {\n            from: virtualScrollSliceRange.value.from,\n            to\n          };\n          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);\n        }\n      });\n    }\n\n    requestAnimationFrame(() => {\n      // if the scroll was changed give up\n      // (another call to setVirtualScrollSliceRange before animation frame)\n      if (prevScrollStart !== scrollDetails.scrollStart) {\n        return;\n      }\n\n      if (rangeChanged === true) {\n        updateVirtualScrollSizes(from);\n      }\n\n      const sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),\n            posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value,\n            posEnd = posStart + virtualScrollSizes[toIndex];\n      let scrollPosition = posStart + offset;\n\n      if (alignEnd !== void 0) {\n        const sizeDiff = sizeAfter - sizeBefore;\n        const scrollStart = scrollDetails.scrollStart + sizeDiff;\n        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === 'end' ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[toIndex]) / 2));\n      }\n\n      prevScrollStart = scrollPosition;\n      setScroll(scrollEl, scrollPosition, props.virtualScrollHorizontal, $q.lang.rtl);\n      emitScroll(toIndex);\n    });\n  }\n\n  function updateVirtualScrollSizes(from) {\n    const contentEl = contentRef.value;\n\n    if (contentEl) {\n      const children = filterProto.call(contentEl.children, el => el.classList && el.classList.contains('q-virtual-scroll--skip') === false),\n            childrenLength = children.length,\n            sizeFn = props.virtualScrollHorizontal === true ? el => el.getBoundingClientRect().width : el => el.offsetHeight;\n      let index = from,\n          size,\n          diff;\n\n      for (let i = 0; i < childrenLength;) {\n        size = sizeFn(children[i]);\n        i++;\n\n        while (i < childrenLength && children[i].classList.contains('q-virtual-scroll--with-prev') === true) {\n          size += sizeFn(children[i]);\n          i++;\n        }\n\n        diff = size - virtualScrollSizes[index];\n\n        if (diff !== 0) {\n          virtualScrollSizes[index] += diff;\n          virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  function onBlurRefocusFn() {\n    contentRef.value !== void 0 && contentRef.value.focus();\n  }\n\n  function localResetVirtualScroll(toIndex, fullReset) {\n    const defaultSize = 1 * virtualScrollItemSizeComputed.value;\n\n    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {\n      virtualScrollSizes = [];\n    }\n\n    const oldVirtualScrollSizesLength = virtualScrollSizes.length;\n    virtualScrollSizes.length = virtualScrollLength.value;\n\n    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {\n      virtualScrollSizes[i] = defaultSize;\n    }\n\n    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize);\n    virtualScrollSizesAgg = [];\n\n    for (let j = 0; j <= jMax; j++) {\n      let size = 0;\n      const iMax = Math.min((j + 1) * aggBucketSize, virtualScrollLength.value);\n\n      for (let i = j * aggBucketSize; i < iMax; i++) {\n        size += virtualScrollSizes[i];\n      }\n\n      virtualScrollSizesAgg.push(size);\n    }\n\n    prevToIndex = -1;\n    prevScrollStart = void 0;\n    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from);\n    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value);\n\n    if (toIndex >= 0) {\n      updateVirtualScrollSizes(virtualScrollSliceRange.value.from);\n      nextTick(() => {\n        scrollTo(toIndex);\n      });\n    } else {\n      onVirtualScrollEvt();\n    }\n  }\n\n  function setVirtualScrollSize(scrollViewSize) {\n    if (scrollViewSize === void 0 && typeof window !== 'undefined') {\n      const scrollEl = getVirtualScrollTarget();\n\n      if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n        scrollViewSize = getScrollDetails(scrollEl, getVirtualScrollEl(), beforeRef.value, afterRef.value, props.virtualScrollHorizontal, $q.lang.rtl, props.virtualScrollStickySizeStart, props.virtualScrollStickySizeEnd).scrollViewSize;\n      }\n    }\n\n    localScrollViewSize = scrollViewSize;\n    const virtualScrollSliceRatioBefore = parseFloat(props.virtualScrollSliceRatioBefore) || 0;\n    const virtualScrollSliceRatioAfter = parseFloat(props.virtualScrollSliceRatioAfter) || 0;\n    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;\n    const view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value);\n    const baseSize = Math.max(1, view, Math.ceil((props.virtualScrollSliceSize > 0 ? props.virtualScrollSliceSize : 10) / multiplier));\n    virtualScrollSliceSizeComputed.value = {\n      total: Math.ceil(baseSize * multiplier),\n      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),\n      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),\n      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),\n      view\n    };\n  }\n\n  function padVirtualScroll(tag, content) {\n    const paddingSize = props.virtualScrollHorizontal === true ? 'width' : 'height';\n    const style = {\n      ['--q-virtual-scroll-item-' + paddingSize]: virtualScrollItemSizeComputed.value + 'px'\n    };\n    return [tag === 'tbody' ? h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'before',\n      ref: beforeRef\n    }, [h('tr', [h('td', {\n      style: {\n        [paddingSize]: `${virtualScrollPaddingBefore.value}px`,\n        ...style\n      },\n      colspan: colspanAttr.value\n    })])]) : h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'before',\n      ref: beforeRef,\n      style: {\n        [paddingSize]: `${virtualScrollPaddingBefore.value}px`,\n        ...style\n      }\n    }), h(tag, {\n      class: 'q-virtual-scroll__content',\n      key: 'content',\n      ref: contentRef,\n      id: vsId,\n      tabindex: -1\n    }, content.flat()), tag === 'tbody' ? h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'after',\n      ref: afterRef\n    }, [h('tr', [h('td', {\n      style: {\n        [paddingSize]: `${virtualScrollPaddingAfter.value}px`,\n        ...style\n      },\n      colspan: colspanAttr.value\n    })])]) : h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'after',\n      ref: afterRef,\n      style: {\n        [paddingSize]: `${virtualScrollPaddingAfter.value}px`,\n        ...style\n      }\n    })];\n  }\n\n  function emitScroll(index) {\n    if (prevToIndex !== index) {\n      props.onVirtualScroll !== void 0 && emit('virtual-scroll', {\n        index,\n        from: virtualScrollSliceRange.value.from,\n        to: virtualScrollSliceRange.value.to - 1,\n        direction: index < prevToIndex ? 'decrease' : 'increase',\n        ref: proxy\n      });\n      prevToIndex = index;\n    }\n  }\n\n  setVirtualScrollSize();\n  const onVirtualScrollEvt = debounce(localOnVirtualScrollEvt, $q.platform.is.ios === true ? 120 : 35);\n  onBeforeMount(() => {\n    setVirtualScrollSize();\n  });\n  let shouldActivate = false;\n  onDeactivated(() => {\n    shouldActivate = true;\n  });\n  onActivated(() => {\n    if (shouldActivate !== true) {\n      return;\n    }\n\n    const scrollEl = getVirtualScrollTarget();\n\n    if (prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n      setScroll(scrollEl, prevScrollStart, props.virtualScrollHorizontal, $q.lang.rtl);\n    } else {\n      scrollTo(prevToIndex);\n    }\n  });\n  setOverflowAnchor !== noop && onBeforeUnmount(() => {\n    const styleSheet = document.getElementById(vsId + '_ss');\n    styleSheet !== null && styleSheet.remove();\n    onVirtualScrollEvt.cancel();\n  }); // expose public methods\n\n  Object.assign(proxy, {\n    scrollTo,\n    reset,\n    refresh\n  });\n  return {\n    virtualScrollSliceRange,\n    virtualScrollSliceSizeComputed,\n    setVirtualScrollSize,\n    onVirtualScrollEvt,\n    localResetVirtualScroll,\n    padVirtualScroll,\n    scrollTo,\n    reset,\n    refresh\n  };\n}","map":{"version":3,"sources":["C:/Users/saina/OneDrive - City University of Hong Kong/Desktop/cityu/Cityu Year 4/FYP/code/frontend_sample2/node_modules/quasar/src/components/virtual-scroll/use-virtual-scroll.js"],"names":["h","ref","computed","watch","onActivated","onDeactivated","onBeforeMount","onBeforeUnmount","nextTick","getCurrentInstance","debounce","noop","rtlHasScrollBug","aggBucketSize","scrollToEdges","id","filterProto","Array","prototype","filter","setOverflowAnchor","__QUASAR_SSR__","window","getComputedStyle","document","body","overflowAnchor","index","ssId","styleSheet","getElementById","createElement","type","head","appendChild","qChildIndex","innerHTML","sumFn","acc","getScrollDetails","parent","child","beforeRef","afterRef","horizontal","rtl","stickyStart","stickyEnd","parentCalc","scrollingElement","documentElement","propElSize","details","scrollStart","scrollViewSize","scrollMaxSize","offsetStart","offsetEnd","pageXOffset","scrollX","scrollLeft","clientWidth","scrollWidth","pageYOffset","scrollY","scrollTop","clientHeight","scrollHeight","el","previousElementSibling","classList","contains","nextElementSibling","parentRect","getBoundingClientRect","childRect","left","width","top","height","setScroll","scroll","scrollTo","offsetWidth","sumSize","sizeAgg","size","from","to","lastTo","length","fromAgg","Math","floor","toAgg","total","slice","reduce","commonVirtScrollProps","virtualScrollSliceSize","Number","String","default","virtualScrollSliceRatioBefore","virtualScrollSliceRatioAfter","virtualScrollItemSize","virtualScrollStickySizeStart","virtualScrollStickySizeEnd","tableColspan","commonVirtPropsList","Object","keys","useVirtualScrollProps","virtualScrollHorizontal","Boolean","onVirtualScroll","Function","useVirtualScroll","virtualScrollLength","getVirtualScrollTarget","getVirtualScrollEl","virtualScrollItemSizeComputed","vm","props","emit","proxy","$q","prevScrollStart","prevToIndex","localScrollViewSize","virtualScrollSizesAgg","virtualScrollSizes","vsId","virtualScrollPaddingBefore","virtualScrollPaddingAfter","virtualScrollSliceSizeComputed","contentRef","virtualScrollSliceRange","colspanAttr","needsReset","value","needsSliceRecalc","setVirtualScrollSize","reset","localResetVirtualScroll","refresh","toIndex","edge","scrollEl","nodeType","scrollDetails","lang","setVirtualScrollSliceRange","min","max","parseInt","indexOf","localOnVirtualScrollEvt","listLastIndex","listEndOffset","updateVirtualScrollSizes","scrollMaxStart","ceil","listOffset","offset","j","align","alignForce","alignEnd","replace","alignRange","rangeChanged","emitScroll","activeElement","contentEl","addEventListener","onBlurRefocusFn","setTimeout","removeEventListener","sizeBefore","tempTo","requestAnimationFrame","sizeAfter","posStart","posEnd","scrollPosition","sizeDiff","round","children","call","childrenLength","sizeFn","offsetHeight","diff","i","focus","fullReset","defaultSize","isArray","oldVirtualScrollSizesLength","jMax","iMax","push","onVirtualScrollEvt","parseFloat","multiplier","view","baseSize","start","center","end","padVirtualScroll","tag","content","paddingSize","style","class","key","colspan","tabindex","flat","direction","platform","is","ios","shouldActivate","remove","cancel","assign"],"mappings":"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","sourcesContent":["import { h, ref, computed, watch, onActivated, onDeactivated, onBeforeMount, onBeforeUnmount, nextTick, getCurrentInstance } from 'vue'\n\nimport debounce from '../../utils/debounce.js'\nimport { noop } from '../../utils/event.js'\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js'\n\nconst aggBucketSize = 1000\n\nconst scrollToEdges = [\n  'start',\n  'center',\n  'end',\n  'start-force',\n  'center-force',\n  'end-force'\n]\n\nlet id = 1\nconst filterProto = Array.prototype.filter\n\nconst setOverflowAnchor = __QUASAR_SSR__ || window.getComputedStyle(document.body).overflowAnchor === void 0\n  ? noop\n  : function (id, index) {\n    const ssId = id + '_ss'\n\n    let styleSheet = document.getElementById(ssId)\n\n    if (styleSheet === null) {\n      styleSheet = document.createElement('style')\n      styleSheet.type = 'text/css'\n      styleSheet.id = ssId\n      document.head.appendChild(styleSheet)\n    }\n\n    if (styleSheet.qChildIndex !== index) {\n      styleSheet.qChildIndex = index\n      styleSheet.innerHTML = `#${ id } > *:nth-child(${ index }) { overflow-anchor: auto }`\n    }\n  }\n\nfunction sumFn (acc, h) {\n  return acc + h\n}\n\nfunction getScrollDetails (\n  parent,\n  child,\n  beforeRef,\n  afterRef,\n  horizontal,\n  rtl,\n  stickyStart,\n  stickyEnd\n) {\n  const\n    parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,\n    propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',\n    details = {\n      scrollStart: 0,\n      scrollViewSize: -stickyStart - stickyEnd,\n      scrollMaxSize: 0,\n      offsetStart: -stickyStart,\n      offsetEnd: -stickyEnd\n    }\n\n  if (horizontal === true) {\n    if (parent === window) {\n      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0\n      details.scrollViewSize += document.documentElement.clientWidth\n    }\n    else {\n      details.scrollStart = parentCalc.scrollLeft\n      details.scrollViewSize += parentCalc.clientWidth\n    }\n    details.scrollMaxSize = parentCalc.scrollWidth\n\n    if (rtl === true) {\n      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart\n    }\n  }\n  else {\n    if (parent === window) {\n      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0\n      details.scrollViewSize += document.documentElement.clientHeight\n    }\n    else {\n      details.scrollStart = parentCalc.scrollTop\n      details.scrollViewSize += parentCalc.clientHeight\n    }\n    details.scrollMaxSize = parentCalc.scrollHeight\n  }\n\n  if (beforeRef !== null) {\n    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetStart += el[ propElSize ]\n      }\n    }\n  }\n\n  if (afterRef !== null) {\n    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetEnd += el[ propElSize ]\n      }\n    }\n  }\n\n  if (child !== parent) {\n    const\n      parentRect = parentCalc.getBoundingClientRect(),\n      childRect = child.getBoundingClientRect()\n\n    if (horizontal === true) {\n      details.offsetStart += childRect.left - parentRect.left\n      details.offsetEnd -= childRect.width\n    }\n    else {\n      details.offsetStart += childRect.top - parentRect.top\n      details.offsetEnd -= childRect.height\n    }\n\n    if (parent !== window) {\n      details.offsetStart += details.scrollStart\n    }\n    details.offsetEnd += details.scrollMaxSize - details.offsetStart\n  }\n\n  return details\n}\n\nfunction setScroll (parent, scroll, horizontal, rtl) {\n  if (scroll === 'end') {\n    scroll = (parent === window ? document.body : parent)[\n      horizontal === true ? 'scrollWidth' : 'scrollHeight'\n    ]\n  }\n\n  if (parent === window) {\n    if (horizontal === true) {\n      if (rtl === true) {\n        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll\n      }\n      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0)\n    }\n    else {\n      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll)\n    }\n  }\n  else if (horizontal === true) {\n    if (rtl === true) {\n      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll\n    }\n    parent.scrollLeft = scroll\n  }\n  else {\n    parent.scrollTop = scroll\n  }\n}\n\nfunction sumSize (sizeAgg, size, from, to) {\n  if (from >= to) { return 0 }\n\n  const\n    lastTo = size.length,\n    fromAgg = Math.floor(from / aggBucketSize),\n    toAgg = Math.floor((to - 1) / aggBucketSize) + 1\n\n  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0)\n\n  if (from % aggBucketSize !== 0) {\n    total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0)\n  }\n  if (to % aggBucketSize !== 0 && to !== lastTo) {\n    total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0)\n  }\n\n  return total\n}\n\nconst commonVirtScrollProps = {\n  virtualScrollSliceSize: {\n    type: [ Number, String ],\n    default: null\n  },\n\n  virtualScrollSliceRatioBefore: {\n    type: [ Number, String ],\n    default: 1\n  },\n\n  virtualScrollSliceRatioAfter: {\n    type: [ Number, String ],\n    default: 1\n  },\n\n  virtualScrollItemSize: {\n    type: [ Number, String ],\n    default: 24\n  },\n\n  virtualScrollStickySizeStart: {\n    type: [ Number, String ],\n    default: 0\n  },\n\n  virtualScrollStickySizeEnd: {\n    type: [ Number, String ],\n    default: 0\n  },\n\n  tableColspan: [ Number, String ]\n}\n\nexport const commonVirtPropsList = Object.keys(commonVirtScrollProps)\n\nexport const useVirtualScrollProps = {\n  virtualScrollHorizontal: Boolean,\n  onVirtualScroll: Function,\n  ...commonVirtScrollProps\n}\n\nexport function useVirtualScroll ({\n  virtualScrollLength, getVirtualScrollTarget, getVirtualScrollEl,\n  virtualScrollItemSizeComputed // optional\n}) {\n  const vm = getCurrentInstance()\n\n  const { props, emit, proxy } = vm\n  const { $q } = proxy\n\n  let prevScrollStart, prevToIndex, localScrollViewSize, virtualScrollSizesAgg = [], virtualScrollSizes\n\n  const vsId = 'qvs_' + id++\n\n  const virtualScrollPaddingBefore = ref(0)\n  const virtualScrollPaddingAfter = ref(0)\n  const virtualScrollSliceSizeComputed = ref({})\n\n  const beforeRef = ref(null)\n  const afterRef = ref(null)\n  const contentRef = ref(null)\n\n  const virtualScrollSliceRange = ref({ from: 0, to: 0 })\n\n  const colspanAttr = computed(() => (props.tableColspan !== void 0 ? props.tableColspan : 100))\n\n  if (virtualScrollItemSizeComputed === void 0) {\n    virtualScrollItemSizeComputed = computed(() => props.virtualScrollItemSize)\n  }\n\n  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ';' + props.virtualScrollHorizontal)\n\n  const needsSliceRecalc = computed(() =>\n    needsReset.value + ';' + props.virtualScrollSliceRatioBefore + ';' + props.virtualScrollSliceRatioAfter\n  )\n\n  watch(needsSliceRecalc, () => { setVirtualScrollSize() })\n  watch(needsReset, reset)\n\n  function reset () {\n    localResetVirtualScroll(prevToIndex, true)\n  }\n\n  function refresh (toIndex) {\n    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex)\n  }\n\n  function scrollTo (toIndex, edge) {\n    const scrollEl = getVirtualScrollTarget()\n\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return\n    }\n\n    const scrollDetails = getScrollDetails(\n      scrollEl,\n      getVirtualScrollEl(),\n      beforeRef.value,\n      afterRef.value,\n      props.virtualScrollHorizontal,\n      $q.lang.rtl,\n      props.virtualScrollStickySizeStart,\n      props.virtualScrollStickySizeEnd\n    )\n\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize)\n\n    setVirtualScrollSliceRange(\n      scrollEl,\n      scrollDetails,\n      Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)),\n      0,\n      scrollToEdges.indexOf(edge) > -1 ? edge : (prevToIndex > -1 && toIndex > prevToIndex ? 'end' : 'start')\n    )\n  }\n\n  function localOnVirtualScrollEvt () {\n    const scrollEl = getVirtualScrollTarget()\n\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return\n    }\n\n    const\n      scrollDetails = getScrollDetails(\n        scrollEl,\n        getVirtualScrollEl(),\n        beforeRef.value,\n        afterRef.value,\n        props.virtualScrollHorizontal,\n        $q.lang.rtl,\n        props.virtualScrollStickySizeStart,\n        props.virtualScrollStickySizeEnd\n      ),\n      listLastIndex = virtualScrollLength.value - 1,\n      listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value\n\n    if (prevScrollStart === scrollDetails.scrollStart) {\n      return\n    }\n\n    if (scrollDetails.scrollMaxSize <= 0) {\n      setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0)\n      return\n    }\n\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize)\n\n    updateVirtualScrollSizes(virtualScrollSliceRange.value.from)\n\n    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize\n      - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd)\n      - Math.min(virtualScrollSizes[ listLastIndex ], scrollDetails.scrollViewSize / 2))\n\n    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {\n      setVirtualScrollSliceRange(\n        scrollEl,\n        scrollDetails,\n        listLastIndex,\n        scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0)\n      )\n\n      return\n    }\n\n    let\n      toIndex = 0,\n      listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,\n      offset = listOffset\n\n    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {\n      listOffset -= virtualScrollPaddingBefore.value\n      toIndex = virtualScrollSliceRange.value.from\n      offset = listOffset\n    }\n    else {\n      for (let j = 0; listOffset >= virtualScrollSizesAgg[ j ] && toIndex < listLastIndex; j++) {\n        listOffset -= virtualScrollSizesAgg[ j ]\n        toIndex += aggBucketSize\n      }\n    }\n\n    while (listOffset > 0 && toIndex < listLastIndex) {\n      listOffset -= virtualScrollSizes[ toIndex ]\n      if (listOffset > -scrollDetails.scrollViewSize) {\n        toIndex++\n        offset = listOffset\n      }\n      else {\n        offset = virtualScrollSizes[ toIndex ] + listOffset\n      }\n    }\n\n    setVirtualScrollSliceRange(\n      scrollEl,\n      scrollDetails,\n      toIndex,\n      offset\n    )\n  }\n\n  function setVirtualScrollSliceRange (scrollEl, scrollDetails, toIndex, offset, align) {\n    const alignForce = typeof align === 'string' && align.indexOf('-force') > -1\n    const alignEnd = alignForce === true ? align.replace('-force', '') : align\n    const alignRange = alignEnd !== void 0 ? alignEnd : 'start'\n\n    let\n      from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[ alignRange ]),\n      to = from + virtualScrollSliceSizeComputed.value.total\n\n    if (to > virtualScrollLength.value) {\n      to = virtualScrollLength.value\n      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total)\n    }\n\n    prevScrollStart = scrollDetails.scrollStart\n\n    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to\n\n    if (rangeChanged === false && alignEnd === void 0) {\n      emitScroll(toIndex)\n      return\n    }\n\n    const { activeElement } = document\n    const contentEl = contentRef.value\n    if (\n      rangeChanged === true\n      && contentEl !== null\n      && contentEl !== activeElement\n      && contentEl.contains(activeElement) === true\n    ) {\n      contentEl.addEventListener('focusout', onBlurRefocusFn)\n\n      setTimeout(() => {\n        contentEl !== void 0 && contentEl.removeEventListener('focusout', onBlurRefocusFn)\n      })\n    }\n\n    setOverflowAnchor(vsId, toIndex - from + 1)\n\n    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0\n\n    if (rangeChanged === true) {\n      // vue key matching algorithm works only if\n      // the array of VNodes changes on only one of the ends\n      // so we first change one end and then the other\n\n      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to\n        ? virtualScrollSliceRange.value.to\n        : to\n\n      virtualScrollSliceRange.value = { from, to: tempTo }\n      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from)\n      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value)\n\n      requestAnimationFrame(() => {\n        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {\n          virtualScrollSliceRange.value = { from: virtualScrollSliceRange.value.from, to }\n          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value)\n        }\n      })\n    }\n\n    requestAnimationFrame(() => {\n      // if the scroll was changed give up\n      // (another call to setVirtualScrollSliceRange before animation frame)\n      if (prevScrollStart !== scrollDetails.scrollStart) {\n        return\n      }\n\n      if (rangeChanged === true) {\n        updateVirtualScrollSizes(from)\n      }\n\n      const\n        sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),\n        posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value,\n        posEnd = posStart + virtualScrollSizes[ toIndex ]\n\n      let scrollPosition = posStart + offset\n\n      if (alignEnd !== void 0) {\n        const sizeDiff = sizeAfter - sizeBefore\n        const scrollStart = scrollDetails.scrollStart + sizeDiff\n\n        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize\n          ? scrollStart\n          : (\n              alignEnd === 'end'\n                ? posEnd - scrollDetails.scrollViewSize\n                : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[ toIndex ]) / 2))\n            )\n      }\n\n      prevScrollStart = scrollPosition\n\n      setScroll(\n        scrollEl,\n        scrollPosition,\n        props.virtualScrollHorizontal,\n        $q.lang.rtl\n      )\n\n      emitScroll(toIndex)\n    })\n  }\n\n  function updateVirtualScrollSizes (from) {\n    const contentEl = contentRef.value\n\n    if (contentEl) {\n      const\n        children = filterProto.call(\n          contentEl.children,\n          el => el.classList && el.classList.contains('q-virtual-scroll--skip') === false\n        ),\n        childrenLength = children.length,\n        sizeFn = props.virtualScrollHorizontal === true\n          ? el => el.getBoundingClientRect().width\n          : el => el.offsetHeight\n\n      let\n        index = from,\n        size, diff\n\n      for (let i = 0; i < childrenLength;) {\n        size = sizeFn(children[ i ])\n        i++\n\n        while (i < childrenLength && children[ i ].classList.contains('q-virtual-scroll--with-prev') === true) {\n          size += sizeFn(children[ i ])\n          i++\n        }\n\n        diff = size - virtualScrollSizes[ index ]\n\n        if (diff !== 0) {\n          virtualScrollSizes[ index ] += diff\n          virtualScrollSizesAgg[ Math.floor(index / aggBucketSize) ] += diff\n        }\n\n        index++\n      }\n    }\n  }\n\n  function onBlurRefocusFn () {\n    contentRef.value !== void 0 && contentRef.value.focus()\n  }\n\n  function localResetVirtualScroll (toIndex, fullReset) {\n    const defaultSize = 1 * virtualScrollItemSizeComputed.value\n\n    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {\n      virtualScrollSizes = []\n    }\n\n    const oldVirtualScrollSizesLength = virtualScrollSizes.length\n\n    virtualScrollSizes.length = virtualScrollLength.value\n\n    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {\n      virtualScrollSizes[ i ] = defaultSize\n    }\n\n    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize)\n    virtualScrollSizesAgg = []\n    for (let j = 0; j <= jMax; j++) {\n      let size = 0\n      const iMax = Math.min((j + 1) * aggBucketSize, virtualScrollLength.value)\n      for (let i = j * aggBucketSize; i < iMax; i++) {\n        size += virtualScrollSizes[ i ]\n      }\n      virtualScrollSizesAgg.push(size)\n    }\n\n    prevToIndex = -1\n    prevScrollStart = void 0\n\n    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from)\n    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value)\n\n    if (toIndex >= 0) {\n      updateVirtualScrollSizes(virtualScrollSliceRange.value.from)\n      nextTick(() => { scrollTo(toIndex) })\n    }\n    else {\n      onVirtualScrollEvt()\n    }\n  }\n\n  function setVirtualScrollSize (scrollViewSize) {\n    if (scrollViewSize === void 0 && typeof window !== 'undefined') {\n      const scrollEl = getVirtualScrollTarget()\n\n      if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n        scrollViewSize = getScrollDetails(\n          scrollEl,\n          getVirtualScrollEl(),\n          beforeRef.value,\n          afterRef.value,\n          props.virtualScrollHorizontal,\n          $q.lang.rtl,\n          props.virtualScrollStickySizeStart,\n          props.virtualScrollStickySizeEnd\n        ).scrollViewSize\n      }\n    }\n\n    localScrollViewSize = scrollViewSize\n\n    const virtualScrollSliceRatioBefore = parseFloat(props.virtualScrollSliceRatioBefore) || 0\n    const virtualScrollSliceRatioAfter = parseFloat(props.virtualScrollSliceRatioAfter) || 0\n    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter\n    const view = scrollViewSize === void 0 || scrollViewSize <= 0\n      ? 1\n      : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value)\n\n    const baseSize = Math.max(\n      1,\n      view,\n      Math.ceil((props.virtualScrollSliceSize > 0 ? props.virtualScrollSliceSize : 10) / multiplier)\n    )\n\n    virtualScrollSliceSizeComputed.value = {\n      total: Math.ceil(baseSize * multiplier),\n      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),\n      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),\n      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),\n      view\n    }\n  }\n\n  function padVirtualScroll (tag, content) {\n    const paddingSize = props.virtualScrollHorizontal === true ? 'width' : 'height'\n    const style = {\n      [ '--q-virtual-scroll-item-' + paddingSize ]: virtualScrollItemSizeComputed.value + 'px'\n    }\n\n    return [\n      tag === 'tbody'\n        ? h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'before',\n          ref: beforeRef\n        }, [\n          h('tr', [\n            h('td', {\n              style: { [ paddingSize ]: `${ virtualScrollPaddingBefore.value }px`, ...style },\n              colspan: colspanAttr.value\n            })\n          ])\n        ])\n        : h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'before',\n          ref: beforeRef,\n          style: { [ paddingSize ]: `${ virtualScrollPaddingBefore.value }px`, ...style }\n        }),\n\n      h(tag, {\n        class: 'q-virtual-scroll__content',\n        key: 'content',\n        ref: contentRef,\n        id: vsId,\n        tabindex: -1\n      }, content.flat()),\n\n      tag === 'tbody'\n        ? h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'after',\n          ref: afterRef\n        }, [\n          h('tr', [\n            h('td', {\n              style: { [ paddingSize ]: `${ virtualScrollPaddingAfter.value }px`, ...style },\n              colspan: colspanAttr.value\n            })\n          ])\n        ])\n        : h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'after',\n          ref: afterRef,\n          style: { [ paddingSize ]: `${ virtualScrollPaddingAfter.value }px`, ...style }\n        })\n    ]\n  }\n\n  function emitScroll (index) {\n    if (prevToIndex !== index) {\n      props.onVirtualScroll !== void 0 && emit('virtual-scroll', {\n        index,\n        from: virtualScrollSliceRange.value.from,\n        to: virtualScrollSliceRange.value.to - 1,\n        direction: index < prevToIndex ? 'decrease' : 'increase',\n        ref: proxy\n      })\n\n      prevToIndex = index\n    }\n  }\n\n  setVirtualScrollSize()\n  const onVirtualScrollEvt = debounce(\n    localOnVirtualScrollEvt,\n    $q.platform.is.ios === true ? 120 : 35\n  )\n\n  onBeforeMount(() => {\n    setVirtualScrollSize()\n  })\n\n  let shouldActivate = false\n\n  onDeactivated(() => {\n    shouldActivate = true\n  })\n\n  onActivated(() => {\n    if (shouldActivate !== true) { return }\n\n    const scrollEl = getVirtualScrollTarget()\n\n    if (prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n      setScroll(\n        scrollEl,\n        prevScrollStart,\n        props.virtualScrollHorizontal,\n        $q.lang.rtl\n      )\n    }\n    else {\n      scrollTo(prevToIndex)\n    }\n  })\n\n  setOverflowAnchor !== noop && onBeforeUnmount(() => {\n    const styleSheet = document.getElementById(vsId + '_ss')\n    styleSheet !== null && styleSheet.remove()\n    onVirtualScrollEvt.cancel()\n  })\n\n  // expose public methods\n  Object.assign(proxy, { scrollTo, reset, refresh })\n\n  return {\n    virtualScrollSliceRange,\n    virtualScrollSliceSizeComputed,\n\n    setVirtualScrollSize,\n    onVirtualScrollEvt,\n    localResetVirtualScroll,\n    padVirtualScroll,\n\n    scrollTo,\n    reset,\n    refresh\n  }\n}\n"]},"metadata":{},"sourceType":"module"}