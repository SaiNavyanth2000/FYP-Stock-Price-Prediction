{"ast":null,"code":"import { h, withDirectives, ref, computed, watch, onMounted, onBeforeUnmount, nextTick, inject, getCurrentInstance } from 'vue';\nimport useHistory from '../../composables/private/use-history.js';\nimport useModelToggle, { useModelToggleProps, useModelToggleEmits } from '../../composables/private/use-model-toggle.js';\nimport usePreventScroll from '../../composables/private/use-prevent-scroll.js';\nimport useTimeout from '../../composables/private/use-timeout.js';\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js';\nimport TouchPan from '../../directives/TouchPan.js';\nimport { createComponent } from '../../utils/private/create.js';\nimport { between } from '../../utils/format.js';\nimport { hSlot, hDir } from '../../utils/private/render.js';\nimport { layoutKey } from '../../utils/private/symbols.js';\nconst duration = 150;\nexport default createComponent({\n  name: 'QDrawer',\n  inheritAttrs: false,\n  props: { ...useModelToggleProps,\n    ...useDarkProps,\n    side: {\n      type: String,\n      default: 'left',\n      validator: v => ['left', 'right'].includes(v)\n    },\n    width: {\n      type: Number,\n      default: 300\n    },\n    mini: Boolean,\n    miniToOverlay: Boolean,\n    miniWidth: {\n      type: Number,\n      default: 57\n    },\n    breakpoint: {\n      type: Number,\n      default: 1023\n    },\n    showIfAbove: Boolean,\n    behavior: {\n      type: String,\n      validator: v => ['default', 'desktop', 'mobile'].includes(v),\n      default: 'default'\n    },\n    bordered: Boolean,\n    elevated: Boolean,\n    overlay: Boolean,\n    persistent: Boolean,\n    noSwipeOpen: Boolean,\n    noSwipeClose: Boolean,\n    noSwipeBackdrop: Boolean\n  },\n  emits: [...useModelToggleEmits, 'on-layout', 'mini-state'],\n\n  setup(props, {\n    slots,\n    emit,\n    attrs\n  }) {\n    const vm = getCurrentInstance();\n    const {\n      proxy: {\n        $q\n      }\n    } = vm;\n    const isDark = useDark(props, $q);\n    const {\n      preventBodyScroll\n    } = usePreventScroll();\n    const {\n      registerTimeout\n    } = useTimeout();\n    const $layout = inject(layoutKey, () => {\n      console.error('QDrawer needs to be child of QLayout');\n    });\n    let lastDesktopState, timerMini, layoutTotalWidthWatcher;\n    const belowBreakpoint = ref(props.behavior === 'mobile' || props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint);\n    const isMini = computed(() => props.mini === true && belowBreakpoint.value !== true);\n    const size = computed(() => isMini.value === true ? props.miniWidth : props.width);\n    const showing = ref(props.showIfAbove === true && belowBreakpoint.value === false ? true : props.modelValue === true);\n    const hideOnRouteChange = computed(() => props.persistent !== true && (belowBreakpoint.value === true || onScreenOverlay.value === true));\n\n    function handleShow(evt, noEvent) {\n      addToHistory();\n      evt !== false && $layout.animate();\n      applyPosition(0);\n\n      if (belowBreakpoint.value === true) {\n        const otherInstance = $layout.instances[otherSide.value];\n\n        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {\n          otherInstance.hide(false);\n        }\n\n        applyBackdrop(1);\n        $layout.isContainer.value !== true && preventBodyScroll(true);\n      } else {\n        applyBackdrop(0);\n        evt !== false && setScrollable(false);\n      }\n\n      registerTimeout(() => {\n        evt !== false && setScrollable(true);\n        noEvent !== true && emit('show', evt);\n      }, duration);\n    }\n\n    function handleHide(evt, noEvent) {\n      removeFromHistory();\n      evt !== false && $layout.animate();\n      applyBackdrop(0);\n      applyPosition(stateDirection.value * size.value);\n      cleanup();\n      noEvent !== true && registerTimeout(() => {\n        emit('hide', evt);\n      }, duration);\n    }\n\n    const {\n      show,\n      hide\n    } = useModelToggle({\n      showing,\n      hideOnRouteChange,\n      handleShow,\n      handleHide\n    });\n    const {\n      addToHistory,\n      removeFromHistory\n    } = useHistory(showing, hide, hideOnRouteChange);\n    const instance = {\n      belowBreakpoint,\n      hide\n    };\n    const rightSide = computed(() => props.side === 'right');\n    const stateDirection = computed(() => ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1));\n    const flagBackdropBg = ref(0);\n    const flagPanning = ref(false);\n    const flagMiniAnimate = ref(false);\n    const flagContentPosition = ref( // starting with \"hidden\" for SSR\n    size.value * stateDirection.value);\n    const otherSide = computed(() => rightSide.value === true ? 'left' : 'right');\n    const offset = computed(() => showing.value === true && belowBreakpoint.value === false && props.overlay === false ? props.miniToOverlay === true ? props.miniWidth : size.value : 0);\n    const fixed = computed(() => props.overlay === true || props.miniToOverlay === true || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1 || $q.platform.is.ios === true && $layout.isContainer.value === true);\n    const onLayout = computed(() => props.overlay === false && showing.value === true && belowBreakpoint.value === false);\n    const onScreenOverlay = computed(() => props.overlay === true && showing.value === true && belowBreakpoint.value === false);\n    const backdropClass = computed(() => 'fullscreen q-drawer__backdrop' + (showing.value === false && flagPanning.value === false ? ' hidden' : ''));\n    const backdropStyle = computed(() => ({\n      backgroundColor: `rgba(0,0,0,${flagBackdropBg.value * 0.4})`\n    }));\n    const headerSlot = computed(() => rightSide.value === true ? $layout.rows.value.top[2] === 'r' : $layout.rows.value.top[0] === 'l');\n    const footerSlot = computed(() => rightSide.value === true ? $layout.rows.value.bottom[2] === 'r' : $layout.rows.value.bottom[0] === 'l');\n    const aboveStyle = computed(() => {\n      const css = {};\n\n      if ($layout.header.space === true && headerSlot.value === false) {\n        if (fixed.value === true) {\n          css.top = `${$layout.header.offset}px`;\n        } else if ($layout.header.space === true) {\n          css.top = `${$layout.header.size}px`;\n        }\n      }\n\n      if ($layout.footer.space === true && footerSlot.value === false) {\n        if (fixed.value === true) {\n          css.bottom = `${$layout.footer.offset}px`;\n        } else if ($layout.footer.space === true) {\n          css.bottom = `${$layout.footer.size}px`;\n        }\n      }\n\n      return css;\n    });\n    const style = computed(() => {\n      const style = {\n        width: `${size.value}px`,\n        transform: `translateX(${flagContentPosition.value}px)`\n      };\n      return belowBreakpoint.value === true ? style : Object.assign(style, aboveStyle.value);\n    });\n    const contentClass = computed(() => 'q-drawer__content fit ' + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto'));\n    const classes = computed(() => `q-drawer q-drawer--${props.side}` + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '') + (props.bordered === true ? ' q-drawer--bordered' : '') + (isDark.value === true ? ' q-drawer--dark q-dark' : '') + (flagPanning.value === true ? ' no-transition' : showing.value === true ? '' : ' q-layout--prevent-focus') + (belowBreakpoint.value === true ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding' : ` q-drawer--${isMini.value === true ? 'mini' : 'standard'}` + (fixed.value === true || onLayout.value !== true ? ' fixed' : '') + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '') + (headerSlot.value === true ? ' q-drawer--top-padding' : '')));\n    const openDirective = computed(() => {\n      // if props.noSwipeOpen !== true\n      const dir = $q.lang.rtl === true ? props.side : otherSide.value;\n      return [[TouchPan, onOpenPan, void 0, {\n        [dir]: true,\n        mouse: true\n      }]];\n    });\n    const contentCloseDirective = computed(() => {\n      // if belowBreakpoint.value === true && props.noSwipeClose !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side;\n      return [[TouchPan, onClosePan, void 0, {\n        [dir]: true,\n        mouse: true\n      }]];\n    });\n    const backdropCloseDirective = computed(() => {\n      // if showing.value === true && props.noSwipeBackdrop !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side;\n      return [[TouchPan, onClosePan, void 0, {\n        [dir]: true,\n        mouse: true,\n        mouseAllDir: true\n      }]];\n    });\n\n    function updateBelowBreakpoint() {\n      updateLocal(belowBreakpoint, props.behavior === 'mobile' || props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint);\n    }\n\n    watch(belowBreakpoint, val => {\n      if (val === true) {\n        // from lg to xs\n        lastDesktopState = showing.value;\n        showing.value === true && hide(false);\n      } else if (props.overlay === false && props.behavior !== 'mobile' && lastDesktopState !== false) {\n        // from xs to lg\n        if (showing.value === true) {\n          applyPosition(0);\n          applyBackdrop(0);\n          cleanup();\n        } else {\n          show(false);\n        }\n      }\n    });\n    watch(() => props.side, (newSide, oldSide) => {\n      if ($layout.instances[oldSide] === instance) {\n        $layout.instances[oldSide] = void 0;\n        $layout[oldSide].space = false;\n        $layout[oldSide].offset = 0;\n      }\n\n      $layout.instances[newSide] = instance;\n      $layout[newSide].size = size.value;\n      $layout[newSide].space = onLayout.value;\n      $layout[newSide].offset = offset.value;\n    });\n    watch($layout.totalWidth, () => {\n      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {\n        updateBelowBreakpoint();\n      }\n    });\n    watch(() => props.behavior + props.breakpoint, updateBelowBreakpoint);\n    watch($layout.isContainer, val => {\n      showing.value === true && preventBodyScroll(val !== true);\n      val === true && updateBelowBreakpoint();\n    });\n    watch($layout.scrollbarWidth, () => {\n      applyPosition(showing.value === true ? 0 : void 0);\n    });\n    watch(offset, val => {\n      updateLayout('offset', val);\n    });\n    watch(onLayout, val => {\n      emit('on-layout', val);\n      updateLayout('space', val);\n    });\n    watch(rightSide, () => {\n      applyPosition();\n    });\n    watch(size, val => {\n      applyPosition();\n      updateSizeOnLayout(props.miniToOverlay, val);\n    });\n    watch(() => props.miniToOverlay, val => {\n      updateSizeOnLayout(val, size.value);\n    });\n    watch(() => $q.lang.rtl, () => {\n      applyPosition();\n    });\n    watch(() => props.mini, () => {\n      if (props.modelValue === true) {\n        animateMini();\n        $layout.animate();\n      }\n    });\n    watch(isMini, val => {\n      emit('mini-state', val);\n    });\n\n    function applyPosition(position) {\n      if (position === void 0) {\n        nextTick(() => {\n          position = showing.value === true ? 0 : size.value;\n          applyPosition(stateDirection.value * position);\n        });\n      } else {\n        if ($layout.isContainer.value === true && rightSide.value === true && (belowBreakpoint.value === true || Math.abs(position) === size.value)) {\n          position += stateDirection.value * $layout.scrollbarWidth.value;\n        }\n\n        flagContentPosition.value = position;\n      }\n    }\n\n    function applyBackdrop(x) {\n      flagBackdropBg.value = x;\n    }\n\n    function setScrollable(v) {\n      const action = v === true ? 'remove' : $layout.isContainer.value !== true ? 'add' : '';\n      action !== '' && document.body.classList[action]('q-body--drawer-toggle');\n    }\n\n    function animateMini() {\n      clearTimeout(timerMini);\n\n      if (vm.proxy && vm.proxy.$el) {\n        // need to speed it up and apply it immediately,\n        // even faster than Vue's nextTick!\n        vm.proxy.$el.classList.add('q-drawer--mini-animate');\n      }\n\n      flagMiniAnimate.value = true;\n      timerMini = setTimeout(() => {\n        flagMiniAnimate.value = false;\n\n        if (vm && vm.proxy && vm.proxy.$el) {\n          vm.proxy.$el.classList.remove('q-drawer--mini-animate');\n        }\n      }, 150);\n    }\n\n    function onOpenPan(evt) {\n      if (showing.value !== false) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been opened (but animation is still pending)\n        return;\n      }\n\n      const width = size.value,\n            position = between(evt.distance.x, 0, width);\n\n      if (evt.isFinal === true) {\n        const opened = position >= Math.min(75, width);\n\n        if (opened === true) {\n          show();\n        } else {\n          $layout.animate();\n          applyBackdrop(0);\n          applyPosition(stateDirection.value * width);\n        }\n\n        flagPanning.value = false;\n        return;\n      }\n\n      applyPosition(($q.lang.rtl === true ? rightSide.value !== true : rightSide.value) ? Math.max(width - position, 0) : Math.min(0, position - width));\n      applyBackdrop(between(position / width, 0, 1));\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true;\n      }\n    }\n\n    function onClosePan(evt) {\n      if (showing.value !== true) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been closed (but animation is still pending)\n        return;\n      }\n\n      const width = size.value,\n            dir = evt.direction === props.side,\n            position = ($q.lang.rtl === true ? dir !== true : dir) ? between(evt.distance.x, 0, width) : 0;\n\n      if (evt.isFinal === true) {\n        const opened = Math.abs(position) < Math.min(75, width);\n\n        if (opened === true) {\n          $layout.animate();\n          applyBackdrop(1);\n          applyPosition(0);\n        } else {\n          hide();\n        }\n\n        flagPanning.value = false;\n        return;\n      }\n\n      applyPosition(stateDirection.value * position);\n      applyBackdrop(between(1 - position / width, 0, 1));\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true;\n      }\n    }\n\n    function cleanup() {\n      preventBodyScroll(false);\n      setScrollable(true);\n    }\n\n    function updateLayout(prop, val) {\n      $layout.update(props.side, prop, val);\n    }\n\n    function updateLocal(prop, val) {\n      if (prop.value !== val) {\n        prop.value = val;\n      }\n    }\n\n    function updateSizeOnLayout(miniToOverlay, size) {\n      updateLayout('size', miniToOverlay === true ? props.miniWidth : size);\n    }\n\n    $layout.instances[props.side] = instance;\n    updateSizeOnLayout(props.miniToOverlay, size.value);\n    updateLayout('space', onLayout.value);\n    updateLayout('offset', offset.value);\n\n    if (props.showIfAbove === true && props.modelValue !== true && showing.value === true && props['onUpdate:modelValue'] !== void 0) {\n      emit('update:modelValue', true);\n    }\n\n    onMounted(() => {\n      emit('on-layout', onLayout.value);\n      emit('mini-state', isMini.value);\n      lastDesktopState = props.showIfAbove === true;\n\n      const fn = () => {\n        const action = showing.value === true ? handleShow : handleHide;\n        action(false, true);\n      };\n\n      if ($layout.totalWidth.value !== 0) {\n        // make sure that all computed properties\n        // have been updated before calling handleShow/handleHide()\n        nextTick(fn);\n        return;\n      }\n\n      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {\n        layoutTotalWidthWatcher();\n        layoutTotalWidthWatcher = void 0;\n\n        if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {\n          show(false);\n        } else {\n          fn();\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();\n      clearTimeout(timerMini);\n      showing.value === true && cleanup();\n\n      if ($layout.instances[props.side] === instance) {\n        $layout.instances[props.side] = void 0;\n        updateLayout('size', 0);\n        updateLayout('offset', 0);\n        updateLayout('space', false);\n      }\n    });\n    return () => {\n      const child = [];\n\n      if (belowBreakpoint.value === true) {\n        props.noSwipeOpen === false && child.push(withDirectives(h('div', {\n          key: 'open',\n          class: `q-drawer__opener fixed-${props.side}`,\n          'aria-hidden': 'true'\n        }), openDirective.value));\n        child.push(hDir('div', {\n          ref: 'backdrop',\n          class: backdropClass.value,\n          style: backdropStyle.value,\n          'aria-hidden': 'true',\n          onClick: hide\n        }, void 0, 'backdrop', props.noSwipeBackdrop !== true && showing.value === true, () => backdropCloseDirective.value));\n      }\n\n      const mini = isMini.value === true && slots.mini !== void 0;\n      const content = [h('div', { ...attrs,\n        key: '' + mini,\n        // required otherwise Vue will not diff correctly\n        class: [contentClass.value, attrs.class]\n      }, mini === true ? slots.mini() : hSlot(slots.default))];\n\n      if (props.elevated === true && showing.value === true) {\n        content.push(h('div', {\n          class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'\n        }));\n      }\n\n      child.push(hDir('aside', {\n        ref: 'content',\n        class: classes.value,\n        style: style.value\n      }, content, 'contentclose', props.noSwipeClose !== true && belowBreakpoint.value === true, () => contentCloseDirective.value));\n      return h('div', {\n        class: 'q-drawer-container'\n      }, child);\n    };\n  }\n\n});","map":{"version":3,"sources":["C:/Users/saina/OneDrive - City University of Hong Kong/Desktop/cityu/Cityu Year 4/FYP/code/frontend_sample2/node_modules/quasar/src/components/drawer/QDrawer.js"],"names":["h","withDirectives","ref","computed","watch","onMounted","onBeforeUnmount","nextTick","inject","getCurrentInstance","useHistory","useModelToggle","useModelToggleProps","useModelToggleEmits","usePreventScroll","useTimeout","useDark","useDarkProps","TouchPan","createComponent","between","hSlot","hDir","layoutKey","duration","name","inheritAttrs","props","side","type","String","default","validator","v","includes","width","Number","mini","Boolean","miniToOverlay","miniWidth","breakpoint","showIfAbove","behavior","bordered","elevated","overlay","persistent","noSwipeOpen","noSwipeClose","noSwipeBackdrop","emits","setup","slots","emit","attrs","vm","proxy","$q","isDark","preventBodyScroll","registerTimeout","$layout","console","error","lastDesktopState","timerMini","layoutTotalWidthWatcher","belowBreakpoint","totalWidth","value","isMini","size","showing","modelValue","hideOnRouteChange","onScreenOverlay","handleShow","evt","noEvent","addToHistory","animate","applyPosition","otherInstance","instances","otherSide","hide","applyBackdrop","isContainer","setScrollable","handleHide","removeFromHistory","stateDirection","cleanup","show","instance","rightSide","lang","rtl","flagBackdropBg","flagPanning","flagMiniAnimate","flagContentPosition","offset","fixed","view","indexOf","platform","is","ios","onLayout","backdropClass","backdropStyle","backgroundColor","headerSlot","rows","top","footerSlot","bottom","aboveStyle","css","header","space","footer","style","transform","Object","assign","contentClass","classes","openDirective","dir","onOpenPan","mouse","contentCloseDirective","onClosePan","backdropCloseDirective","mouseAllDir","updateBelowBreakpoint","updateLocal","val","newSide","oldSide","document","qScrollPrevented","scrollbarWidth","updateLayout","updateSizeOnLayout","animateMini","position","Math","abs","x","action","body","classList","clearTimeout","$el","add","setTimeout","remove","distance","isFinal","opened","min","max","isFirst","direction","prop","update","fn","child","push","key","class","onClick","content"],"mappings":"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","sourcesContent":["import { h, withDirectives, ref, computed, watch, onMounted, onBeforeUnmount, nextTick, inject, getCurrentInstance } from 'vue'\n\nimport useHistory from '../../composables/private/use-history.js'\nimport useModelToggle, { useModelToggleProps, useModelToggleEmits } from '../../composables/private/use-model-toggle.js'\nimport usePreventScroll from '../../composables/private/use-prevent-scroll.js'\nimport useTimeout from '../../composables/private/use-timeout.js'\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js'\n\nimport TouchPan from '../../directives/TouchPan.js'\n\nimport { createComponent } from '../../utils/private/create.js'\nimport { between } from '../../utils/format.js'\nimport { hSlot, hDir } from '../../utils/private/render.js'\nimport { layoutKey } from '../../utils/private/symbols.js'\n\nconst duration = 150\n\nexport default createComponent({\n  name: 'QDrawer',\n\n  inheritAttrs: false,\n\n  props: {\n    ...useModelToggleProps,\n    ...useDarkProps,\n\n    side: {\n      type: String,\n      default: 'left',\n      validator: v => [ 'left', 'right' ].includes(v)\n    },\n\n    width: {\n      type: Number,\n      default: 300\n    },\n\n    mini: Boolean,\n    miniToOverlay: Boolean,\n    miniWidth: {\n      type: Number,\n      default: 57\n    },\n\n    breakpoint: {\n      type: Number,\n      default: 1023\n    },\n    showIfAbove: Boolean,\n\n    behavior: {\n      type: String,\n      validator: v => [ 'default', 'desktop', 'mobile' ].includes(v),\n      default: 'default'\n    },\n\n    bordered: Boolean,\n    elevated: Boolean,\n\n    overlay: Boolean,\n    persistent: Boolean,\n    noSwipeOpen: Boolean,\n    noSwipeClose: Boolean,\n    noSwipeBackdrop: Boolean\n  },\n\n  emits: [\n    ...useModelToggleEmits,\n    'on-layout', 'mini-state'\n  ],\n\n  setup (props, { slots, emit, attrs }) {\n    const vm = getCurrentInstance()\n    const { proxy: { $q } } = vm\n\n    const isDark = useDark(props, $q)\n    const { preventBodyScroll } = usePreventScroll()\n    const { registerTimeout } = useTimeout()\n\n    const $layout = inject(layoutKey, () => {\n      console.error('QDrawer needs to be child of QLayout')\n    })\n\n    let lastDesktopState, timerMini, layoutTotalWidthWatcher\n\n    const belowBreakpoint = ref(\n      props.behavior === 'mobile'\n      || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)\n    )\n\n    const isMini = computed(() =>\n      props.mini === true && belowBreakpoint.value !== true\n    )\n\n    const size = computed(() => (\n      isMini.value === true\n        ? props.miniWidth\n        : props.width\n    ))\n\n    const showing = ref(\n      props.showIfAbove === true && belowBreakpoint.value === false\n        ? true\n        : props.modelValue === true\n    )\n\n    const hideOnRouteChange = computed(() =>\n      props.persistent !== true\n      && (belowBreakpoint.value === true || onScreenOverlay.value === true)\n    )\n\n    function handleShow (evt, noEvent) {\n      addToHistory()\n\n      evt !== false && $layout.animate()\n      applyPosition(0)\n\n      if (belowBreakpoint.value === true) {\n        const otherInstance = $layout.instances[ otherSide.value ]\n        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {\n          otherInstance.hide(false)\n        }\n\n        applyBackdrop(1)\n        $layout.isContainer.value !== true && preventBodyScroll(true)\n      }\n      else {\n        applyBackdrop(0)\n        evt !== false && setScrollable(false)\n      }\n\n      registerTimeout(() => {\n        evt !== false && setScrollable(true)\n        noEvent !== true && emit('show', evt)\n      }, duration)\n    }\n\n    function handleHide (evt, noEvent) {\n      removeFromHistory()\n\n      evt !== false && $layout.animate()\n\n      applyBackdrop(0)\n      applyPosition(stateDirection.value * size.value)\n\n      cleanup()\n\n      noEvent !== true && registerTimeout(() => {\n        emit('hide', evt)\n      }, duration)\n    }\n\n    const { show, hide } = useModelToggle({\n      showing,\n      hideOnRouteChange,\n      handleShow,\n      handleHide\n    })\n\n    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange)\n\n    const instance = {\n      belowBreakpoint,\n      hide\n    }\n\n    const rightSide = computed(() => props.side === 'right')\n\n    const stateDirection = computed(() =>\n      ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)\n    )\n\n    const flagBackdropBg = ref(0)\n    const flagPanning = ref(false)\n    const flagMiniAnimate = ref(false)\n    const flagContentPosition = ref( // starting with \"hidden\" for SSR\n      size.value * stateDirection.value\n    )\n\n    const otherSide = computed(() => (rightSide.value === true ? 'left' : 'right'))\n    const offset = computed(() => (\n      showing.value === true && belowBreakpoint.value === false && props.overlay === false\n        ? (props.miniToOverlay === true ? props.miniWidth : size.value)\n        : 0\n    ))\n\n    const fixed = computed(() =>\n      props.overlay === true\n      || props.miniToOverlay === true\n      || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1\n      || ($q.platform.is.ios === true && $layout.isContainer.value === true)\n    )\n\n    const onLayout = computed(() =>\n      props.overlay === false\n      && showing.value === true\n      && belowBreakpoint.value === false\n    )\n\n    const onScreenOverlay = computed(() =>\n      props.overlay === true\n      && showing.value === true\n      && belowBreakpoint.value === false\n    )\n\n    const backdropClass = computed(() =>\n      'fullscreen q-drawer__backdrop'\n      + (showing.value === false && flagPanning.value === false ? ' hidden' : '')\n    )\n\n    const backdropStyle = computed(() => ({\n      backgroundColor: `rgba(0,0,0,${ flagBackdropBg.value * 0.4 })`\n    }))\n\n    const headerSlot = computed(() => (\n      rightSide.value === true\n        ? $layout.rows.value.top[ 2 ] === 'r'\n        : $layout.rows.value.top[ 0 ] === 'l'\n    ))\n\n    const footerSlot = computed(() => (\n      rightSide.value === true\n        ? $layout.rows.value.bottom[ 2 ] === 'r'\n        : $layout.rows.value.bottom[ 0 ] === 'l'\n    ))\n\n    const aboveStyle = computed(() => {\n      const css = {}\n\n      if ($layout.header.space === true && headerSlot.value === false) {\n        if (fixed.value === true) {\n          css.top = `${ $layout.header.offset }px`\n        }\n        else if ($layout.header.space === true) {\n          css.top = `${ $layout.header.size }px`\n        }\n      }\n\n      if ($layout.footer.space === true && footerSlot.value === false) {\n        if (fixed.value === true) {\n          css.bottom = `${ $layout.footer.offset }px`\n        }\n        else if ($layout.footer.space === true) {\n          css.bottom = `${ $layout.footer.size }px`\n        }\n      }\n\n      return css\n    })\n\n    const style = computed(() => {\n      const style = {\n        width: `${ size.value }px`,\n        transform: `translateX(${ flagContentPosition.value }px)`\n      }\n\n      return belowBreakpoint.value === true\n        ? style\n        : Object.assign(style, aboveStyle.value)\n    })\n\n    const contentClass = computed(() =>\n      'q-drawer__content fit '\n      + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto')\n    )\n\n    const classes = computed(() =>\n      `q-drawer q-drawer--${ props.side }`\n      + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '')\n      + (props.bordered === true ? ' q-drawer--bordered' : '')\n      + (isDark.value === true ? ' q-drawer--dark q-dark' : '')\n      + (\n        flagPanning.value === true\n          ? ' no-transition'\n          : (showing.value === true ? '' : ' q-layout--prevent-focus')\n      )\n      + (\n        belowBreakpoint.value === true\n          ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding'\n          : ` q-drawer--${ isMini.value === true ? 'mini' : 'standard' }`\n          + (fixed.value === true || onLayout.value !== true ? ' fixed' : '')\n          + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '')\n          + (headerSlot.value === true ? ' q-drawer--top-padding' : '')\n      )\n    )\n\n    const openDirective = computed(() => {\n      // if props.noSwipeOpen !== true\n      const dir = $q.lang.rtl === true ? props.side : otherSide.value\n\n      return [ [\n        TouchPan,\n        onOpenPan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true\n        }\n      ] ]\n    })\n\n    const contentCloseDirective = computed(() => {\n      // if belowBreakpoint.value === true && props.noSwipeClose !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side\n\n      return [ [\n        TouchPan,\n        onClosePan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true\n        }\n      ] ]\n    })\n\n    const backdropCloseDirective = computed(() => {\n      // if showing.value === true && props.noSwipeBackdrop !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side\n\n      return [ [\n        TouchPan,\n        onClosePan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true,\n          mouseAllDir: true\n        }\n      ] ]\n    })\n\n    function updateBelowBreakpoint () {\n      updateLocal(belowBreakpoint, (\n        props.behavior === 'mobile'\n        || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)\n      ))\n    }\n\n    watch(belowBreakpoint, val => {\n      if (val === true) { // from lg to xs\n        lastDesktopState = showing.value\n        showing.value === true && hide(false)\n      }\n      else if (\n        props.overlay === false\n        && props.behavior !== 'mobile'\n        && lastDesktopState !== false\n      ) { // from xs to lg\n        if (showing.value === true) {\n          applyPosition(0)\n          applyBackdrop(0)\n          cleanup()\n        }\n        else {\n          show(false)\n        }\n      }\n    })\n\n    watch(() => props.side, (newSide, oldSide) => {\n      if ($layout.instances[ oldSide ] === instance) {\n        $layout.instances[ oldSide ] = void 0\n        $layout[ oldSide ].space = false\n        $layout[ oldSide ].offset = 0\n      }\n\n      $layout.instances[ newSide ] = instance\n      $layout[ newSide ].size = size.value\n      $layout[ newSide ].space = onLayout.value\n      $layout[ newSide ].offset = offset.value\n    })\n\n    watch($layout.totalWidth, () => {\n      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {\n        updateBelowBreakpoint()\n      }\n    })\n\n    watch(\n      () => props.behavior + props.breakpoint,\n      updateBelowBreakpoint\n    )\n\n    watch($layout.isContainer, val => {\n      showing.value === true && preventBodyScroll(val !== true)\n      val === true && updateBelowBreakpoint()\n    })\n\n    watch($layout.scrollbarWidth, () => {\n      applyPosition(showing.value === true ? 0 : void 0)\n    })\n\n    watch(offset, val => { updateLayout('offset', val) })\n\n    watch(onLayout, val => {\n      emit('on-layout', val)\n      updateLayout('space', val)\n    })\n\n    watch(rightSide, () => { applyPosition() })\n\n    watch(size, val => {\n      applyPosition()\n      updateSizeOnLayout(props.miniToOverlay, val)\n    })\n\n    watch(() => props.miniToOverlay, val => {\n      updateSizeOnLayout(val, size.value)\n    })\n\n    watch(() => $q.lang.rtl, () => { applyPosition() })\n\n    watch(() => props.mini, () => {\n      if (props.modelValue === true) {\n        animateMini()\n        $layout.animate()\n      }\n    })\n\n    watch(isMini, val => { emit('mini-state', val) })\n\n    function applyPosition (position) {\n      if (position === void 0) {\n        nextTick(() => {\n          position = showing.value === true ? 0 : size.value\n          applyPosition(stateDirection.value * position)\n        })\n      }\n      else {\n        if (\n          $layout.isContainer.value === true\n          && rightSide.value === true\n          && (belowBreakpoint.value === true || Math.abs(position) === size.value)\n        ) {\n          position += stateDirection.value * $layout.scrollbarWidth.value\n        }\n\n        flagContentPosition.value = position\n      }\n    }\n\n    function applyBackdrop (x) {\n      flagBackdropBg.value = x\n    }\n\n    function setScrollable (v) {\n      const action = v === true\n        ? 'remove'\n        : ($layout.isContainer.value !== true ? 'add' : '')\n\n      action !== '' && document.body.classList[ action ]('q-body--drawer-toggle')\n    }\n\n    function animateMini () {\n      clearTimeout(timerMini)\n\n      if (vm.proxy && vm.proxy.$el) {\n        // need to speed it up and apply it immediately,\n        // even faster than Vue's nextTick!\n        vm.proxy.$el.classList.add('q-drawer--mini-animate')\n      }\n\n      flagMiniAnimate.value = true\n      timerMini = setTimeout(() => {\n        flagMiniAnimate.value = false\n        if (vm && vm.proxy && vm.proxy.$el) {\n          vm.proxy.$el.classList.remove('q-drawer--mini-animate')\n        }\n      }, 150)\n    }\n\n    function onOpenPan (evt) {\n      if (showing.value !== false) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been opened (but animation is still pending)\n        return\n      }\n\n      const\n        width = size.value,\n        position = between(evt.distance.x, 0, width)\n\n      if (evt.isFinal === true) {\n        const opened = position >= Math.min(75, width)\n\n        if (opened === true) {\n          show()\n        }\n        else {\n          $layout.animate()\n          applyBackdrop(0)\n          applyPosition(stateDirection.value * width)\n        }\n\n        flagPanning.value = false\n        return\n      }\n\n      applyPosition(\n        ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value)\n          ? Math.max(width - position, 0)\n          : Math.min(0, position - width)\n      )\n      applyBackdrop(\n        between(position / width, 0, 1)\n      )\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true\n      }\n    }\n\n    function onClosePan (evt) {\n      if (showing.value !== true) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been closed (but animation is still pending)\n        return\n      }\n\n      const\n        width = size.value,\n        dir = evt.direction === props.side,\n        position = ($q.lang.rtl === true ? dir !== true : dir)\n          ? between(evt.distance.x, 0, width)\n          : 0\n\n      if (evt.isFinal === true) {\n        const opened = Math.abs(position) < Math.min(75, width)\n\n        if (opened === true) {\n          $layout.animate()\n          applyBackdrop(1)\n          applyPosition(0)\n        }\n        else {\n          hide()\n        }\n\n        flagPanning.value = false\n        return\n      }\n\n      applyPosition(stateDirection.value * position)\n      applyBackdrop(between(1 - position / width, 0, 1))\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true\n      }\n    }\n\n    function cleanup () {\n      preventBodyScroll(false)\n      setScrollable(true)\n    }\n\n    function updateLayout (prop, val) {\n      $layout.update(props.side, prop, val)\n    }\n\n    function updateLocal (prop, val) {\n      if (prop.value !== val) {\n        prop.value = val\n      }\n    }\n\n    function updateSizeOnLayout (miniToOverlay, size) {\n      updateLayout('size', miniToOverlay === true ? props.miniWidth : size)\n    }\n\n    $layout.instances[ props.side ] = instance\n    updateSizeOnLayout(props.miniToOverlay, size.value)\n    updateLayout('space', onLayout.value)\n    updateLayout('offset', offset.value)\n\n    if (\n      props.showIfAbove === true\n      && props.modelValue !== true\n      && showing.value === true\n      && props[ 'onUpdate:modelValue' ] !== void 0\n    ) {\n      emit('update:modelValue', true)\n    }\n\n    onMounted(() => {\n      emit('on-layout', onLayout.value)\n      emit('mini-state', isMini.value)\n\n      lastDesktopState = props.showIfAbove === true\n\n      const fn = () => {\n        const action = showing.value === true ? handleShow : handleHide\n        action(false, true)\n      }\n\n      if ($layout.totalWidth.value !== 0) {\n        // make sure that all computed properties\n        // have been updated before calling handleShow/handleHide()\n        nextTick(fn)\n        return\n      }\n\n      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {\n        layoutTotalWidthWatcher()\n        layoutTotalWidthWatcher = void 0\n\n        if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {\n          show(false)\n        }\n        else {\n          fn()\n        }\n      })\n    })\n\n    onBeforeUnmount(() => {\n      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher()\n      clearTimeout(timerMini)\n\n      showing.value === true && cleanup()\n\n      if ($layout.instances[ props.side ] === instance) {\n        $layout.instances[ props.side ] = void 0\n        updateLayout('size', 0)\n        updateLayout('offset', 0)\n        updateLayout('space', false)\n      }\n    })\n\n    return () => {\n      const child = []\n\n      if (belowBreakpoint.value === true) {\n        props.noSwipeOpen === false && child.push(\n          withDirectives(\n            h('div', {\n              key: 'open',\n              class: `q-drawer__opener fixed-${ props.side }`,\n              'aria-hidden': 'true'\n            }),\n            openDirective.value\n          )\n        )\n\n        child.push(\n          hDir(\n            'div',\n            {\n              ref: 'backdrop',\n              class: backdropClass.value,\n              style: backdropStyle.value,\n              'aria-hidden': 'true',\n              onClick: hide\n            },\n            void 0,\n            'backdrop',\n            props.noSwipeBackdrop !== true && showing.value === true,\n            () => backdropCloseDirective.value\n          )\n        )\n      }\n\n      const mini = isMini.value === true && slots.mini !== void 0\n      const content = [\n        h('div', {\n          ...attrs,\n          key: '' + mini, // required otherwise Vue will not diff correctly\n          class: [\n            contentClass.value,\n            attrs.class\n          ]\n        }, mini === true\n          ? slots.mini()\n          : hSlot(slots.default)\n        )\n      ]\n\n      if (props.elevated === true && showing.value === true) {\n        content.push(\n          h('div', {\n            class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'\n          })\n        )\n      }\n\n      child.push(\n        hDir(\n          'aside',\n          { ref: 'content', class: classes.value, style: style.value },\n          content,\n          'contentclose',\n          props.noSwipeClose !== true && belowBreakpoint.value === true,\n          () => contentCloseDirective.value\n        )\n      )\n\n      return h('div', { class: 'q-drawer-container' }, child)\n    }\n  }\n})\n"]},"metadata":{},"sourceType":"module"}